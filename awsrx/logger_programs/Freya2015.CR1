'CR1000 Program for the PROMICE AWSs 2008/09
'Written by Michele Citterio, GEUS, Copenhagen.
'Dirk's version, 25/03/2009.
'Implemented binary transmission, data and rates settings unchanged MCIT 25/04/2009
'Updated for NAL 9601-DGS-LP, added forced transmission and debug trace signatures MCIT 29/06/2010
'Added longer ventilation time (settable) when battery is above a threshold (settable) MCIT 13/07/2010
'Fixed binary encoding when GPS NMEA time field has unconsistent length (new NAL devices) MCIT 16/07/2010
'V7 2010: Changed settings for LongerAdvanceFanStart, LongerFanBattThre, LoBattResHyst DVA 16/7/2010
'V2012: New memory allocations and new SlimTableMem table only uning internal memory: safety against corrupted flashcards. MCIT 11/06/2012
'V2012n: New modems once again. Try to get the little ones to work. **NOT WORKING-DON'T USE!** The new NALs crash and reboot after receiving 
'        the binary data
'V2013a: allocate more memory for TxStringUnstripped TxBufferString. TxStringMaxLen set back to its proper value of 340. MCIT 12/02/2013
'V2013b: Make the new NAL modems work. They do not comply with the command to switch off the radio so this consumes more power than needed. MCIT 09/07/2013
'V2013c: Corrected again the modem reboot on binary data. Occasionally, 3 bytes were sent instead of two as the mandatory checksum. (MCIT 15/07/2013)
'v2014a: The two SR50A now can have the same SDI channel number, preferably 0, set in the SR50Address1 (for snow) and SR50Address2 (for ice).
'        In case the program cannot communicate with any or both of the CR50A's, it will try different combinations of channel numbers 0 and 1
'        as well as wiring positions C3 and C7 on the CR1000, so that wrong SR50_wired_together, SR50Address1 or SR50Address2 settings, or 
'        forgetting to move the blue wire of the snow SR50A from C7 to C3, or sensors programmed for ch. 1 instead of 0 will not prevent 
'        the logger from finding and reading the sensor. However, those retries take time and power: worst case with all settings wrong is 4 
'        seconds with current timeouts. For refrence, 1 second at that point of the scan loop corresponds to ca. 2% of power consumption.
'        Note that support for Garmin GPS is incompatible with the wiring needed for the SR50A modification and is commented out. MCIT 9/7/2014
'v2014b: Fixed typo in variable name (MCIT 16/7/2014)
'v2014c: Added CardYears setting (default: ignored, use entire card as usual) to limit the size of the file created on the flashcard. This
'        speeds up card initialization at logger startup/compile time for large cards. To activate this functionality, comment/uncomment as 
'        described in the comments to the second line in the TableMem and TableDiagnostic tables in the code. Note that formatting a 
'        flashcard still needs to go over the entire card and it is therefore not faster. Formatting however is not needed if the 
'        card inserted in the logger is already formatted. Note also that setting a number of years so that the files created on the card 
'        use less than half the available space may prevent a problem that occurs when a card already contaning data from a different 
'        datalogger or a different program version is installed in a station without being reformatted. In such case, the datalogger would 
'        leave the existing data alone and, not findng any more free space, would not write to the card at all (see docs. for 
'        CRBasic CardOut function). Also, increased winter TX rate from daily to 3-hourly. MCIT 17/06/2014
'v2014d: identical to v2014c except for the settings of SR50_wired_together = False and SR50_wired_together = 0, see below for guidance:
' 
' common cases:
' 1  old way: wiring unchanged with both blue wires in C7 AND SR50A on stakes set to ch. 0 AND SR50a on tripod set to ch. 1 -> OK, use v2014c
' 2  wiring updated (blue wire from Plug 8 moved to C3, the other left in C7) AND both SR50A on stakes and on tripod set to ch.0 -> OK, use v2014d
' 3  wiring updated but the SR50A on tripod is still set to ch. 1 -> use 2014d and set SR50Address1 = 1 below, or leave it to 0 and
'    accept a little higher daily power consumption (in this case ca. 2% more)
' IMPORTANT: if wiring is unchanged AND both SR50A on stakes and on tripod are set to the same channel, none will work - irrespective of program!
'
'v2015a: Derived from v2014d
'        Improved resolution of transmitted atmospheric pressure by subtracting 1000 from AirPressure so as to prevent loss of first decimal 
'        in FP2 number type. A corresponding offset of 1000 must now be added on the receiving end after decoding of the binary value.
'        Reverted winter transmission rate from 3-hourly (18) as in 2014 to the 2013 and earlier rate of daily (144) messages.
'        Removed wind direction variability from all transmissions.
'        Set new binary format ID (6) because the messages are now shorter (no wind direction 
'        variability) are now 2 bytes shorter: GEUS database people need to be informed of this.\  
'        Renamed BinaryTxFormatRevision to BinaryTxFormatID
'        Reduced AdvanceGPSstart from 480 to 300 (5 minutes) as it is sufficient and saves power.
'
'v. Freya2015: for ZAMG Vienna, same as PROMICE v2015a but with different winter and summer rates and different binary message fromat (binary ID 42)
'
'        
'Expected debug trace signatures in <dbg_trace_sig> and <dbg_trace_sig_bak>:
'[I0123]  successful NAL module powerup and initialization
'[I013]  failed NAL module powerup and initialization: check power and serial connections
'[G01[I0123]2]  gps powerup and initialization at <AdvanceGPSstart> sec. before the mesurement scan
'[G01[I013][I013]  failed gps powerup and initialization: check power and serial connections
'[S01[T0[I0123]1234567]234]  successful summer tx
'[S01[T0[I0123]1234567]234]  successful forced summer tx
'[S01[T0[I0123]123456567]234]  successful summer tx at the second retry
'[S01[T0[I0123]1234567]231[T0[I0123]1234567]234]  successful summer tx followed by successful tx of an older queued message
'[S01[T0[I0123]1234567]231[T0[I0123]1234565)24]  successful summer tx followed by failed attempt to send an older queued message
'[S01[T0[I0123]12345)24]  attempt at summer tx failed due to no Iridium satellite available
'[W01[T0[I0123]1234565)24]  attempt at winter tx, with 1 retries, failed due to poor Iridium reception
'[W01[T0[I0123]12345656)24]  attempt at winter tx, with 2 retries, failed due to poor Iridium reception
'[W01[T0[I0123]123456565)24]  attempt at winter tx, also with 2 retries, failed due to poor Iridium reception
'############################################################################


SequentialMode
' user settings -------------------------------------------------------------------------------------------------------
' set these to fit your application
Const ScanRate = 600              ' every 600 sec for Promice. Can't be shorter than 15 + TxMaxInitAttempts + 2*TxTimeout + 60.
Const MemSaveRate = 1             ' every 1 scan for Promice. This is both the averaging and the memory saving rate. 1 means: 'save all, don't average'.
Const SlimMemSaveRate = 6         ' every 6 scan for Promice. This is like MemSaveRate but only applies to the internal datalogger memory - MCIT 6/2012
Const SummerTxRate = 24            ' after 24 scans (hourly) for Promice. This is both the averaging and the transmission rate. Can't be shorter than 2*TxTimeout + 1 minute.
Const WinterTxRate = 144           ' after 144 scans (3-hourly) daily for Promice. Before 2014 it was 144 (daily). This is both the averaging and the transmission rate. Can't be shorter than 2*TxTimeout + 1 minute.
Const SummerGPSrate = 24           ' after 24 scans (hourly) for Promice. Must be an integer fraction of SummerTxRate.
Const WinterGPSrate = 144         ' after 144 scans (daily) for Promice. Must be an integer fraction of WinterTxRate.
Const SizeTableBuffer = 100       ' in number of records. This is the max number of unsent messages in the queue.
Const DiagnosticsRate = 168       ' In hours. Not sure can be set too low, so here it is once every 4 weeks. Best set to coincide with an already scheduled TX time.
Const AppendInstantaneous = False ' Append instantaneous values to transmitted means.
Const HoursInstantaneous = 6      ' every 6 hours for Promice. Choices are either 3 or 6.
Const BeginOfSummer = 90          ' on day 100 for Promice. 90 is April 1.
Const BeginOfWinter = 274         ' on day 300 for Promice. 274 is September 30.
Const BinaryTxFormatID = 44       ' it must be set here, the actual binary codes are produced internally. Valid integers: 1..45 (46..48 reserved for testing, 49=extended)
Const SR50Address1 = 0            ' SDI12 address snow height SR50. Can only by 0 or 1
Const SR50Address2 = 0            ' SDI12 address ice height SR50. Can only be 0 or 1
Const AdvanceFanStart = 2         ' in number of FastScans. How much in advance of the scans the fan in the Rotronics shield starts, in sec (=40)
Const LongerAdvanceFanStart = 4   ' in number of FastScans. Used in place of AdvanceFanStart when voltage higher than LongerFanBatThre
Const AdvanceGPSstart = 300       ' in sec. (can probably be safely reduced to 300)
Const TransmitBinary = True
Const SR50_wired_together = False ' True for stations with 2 blue wires in C7, False for newer stations with one blue wire each in C3 (for snow) and C7 (for ice)
Const CardYears = 4               ' (ignored by default, only used if the relevant CardOut commands are uncommented in the declaration of the
'                                   TableMem and TableDiagnostc tables in the code)only set aside and initialize enough memory on the card 
'                                   for this much time. Needed to avoid falling asleep while starting a station with a large flashcard. 
'                                   8 years is a good number to allow at least one mistake (with the old 256 Mb cards, more with larger cards)
'                                   of putting in an unformatted card with data from a different logger or prog version, which would not 
'                                   otherwise accept a new table and would not log anything (see CRBasic docs of CardOut for why)

' internals - be sure you know what you do before tweaking these, and you test extensively. 
' normal users will not need to look here, scan rates and the such can all be set with the variables above
Const GPSType = "N"               ' GARMIN is not supported anymore (was: use 'G' for Garmin, 'N' for the one integrated in the NAL Iridium module, or anything else for none)
Const FastScanReps = 10           ' how many times to run Measure routine in fastscan mode before exiting to the normal mode, in FastScan cycles.
Const FastScanRate = 20           ' how often to run the Measure routine when in fastscan mode, in seconds
Const GPS2UTC = 14                ' in seconds. The time lag between UTC time and GPS (which doesn't have leap seconds)
Const AllowableTimeDrift = 5      ' in sec. Must be <= than FastScanRate for reliable operation
Const KeepSyncToGPStime = False   ' UNTESTED!!! Will sync. to GPS time only if it isn't more than AllowableTimeDrift and less than a FastScanRate off (i.e., 20 sec.)
Const AllowResetToGPStime = False ' UNTESTED!!! Will reset to GPS time, no matter how different it is from the internal clock
Const TxStringMaxLen = 340        ' may be increased with future releases of the Iridium module (see docs)'Restored to 340 beause the NAL hardware can't take more and may choke(MCIT)
Const TxMaxInitAttempts = 5       ' had to be increased for the new NAL things (was: max 3, more doesn't make any sense and the wasted time can interfere with normal program's flow). Reduced from 20 to 5 (MCIT 6/2014)
Const TxTimeout = 30              ' in sec, before the Tx sub times out. If service becomes avail but SBDI fails, it tries once again for maximum as long as another TxTimeout (=60)
Const SR50Warmup = 3              ' in seconds
Const HygroClipWarmup = 4         ' warm-up time needed by the HygroClip module after power is supplied, in sec.
Const NT1400Warmup = 5            ' time required for the pressure transmitter before it is read
Const GarminWarmup = 3            ' in seconds (doesn't mean it will then output a fix, but at least it will talk on the serial bus)
Const GarminBaudRate = 1200       ' Damn Garmin!!!!! Some units come preset at 1200 bauds, others at 4800. You must guess what's yours or the logger OS hangs!!!
Const LongerFanBattThre = 13      ' in volts. Do not set to less than 13. ... Sorry, Dirk made it 12.6
Const LoBattThre = 11.5           ' The threshold in V, entering powersave mode with no fan and no TX. 0 disables this protection.
Const LoBattResHyst = 0.2         ' The hysteresis in V above LoBattThre for resetting Low_Batt to normal. Too low a value may lead to instability.

' Variables -------------------------------------------------------------------------------------------------------

Public AirPressure            ' by CS100
Public Temperature            ' by PT100 in Rotronics assembly
Public Temperature2           ' by HygroClip in Rotronics assembly
Public RelativeHumidity       ' by HygroClip in Rotronics assembly
Public WindSpeed              ' by Young
Public WindDirection          ' by Young
Public ShortwaveRadiationIn   ' by CNR1 Kipp & Zonen
Public ShortwaveRadiationOut  ' by CNR1
Public LongwaveRadiationIn    ' by CNR1
Public LongwaveRadiationOut   ' by CNR1
Public TemperatureRadSensor   ' by CNR1
Public Height1(2)             ' by SR50A, snow, on tripod boom
Alias Height1(1) = SnowHeight
Alias Height1(2) = SnowHeightQuality
Public Height2(2)             ' by SR50A, ice, on separate stakes assembly
Alias Height2(1) = SurfaceHeight
Alias Height2(2) = SurfaceHeightQuality
Public IceHeight              ' by NT1400
Public TemperatureIce(8)      ' by thermistor string
Alias TemperatureIce(1) = TemperatureIce1m
Alias TemperatureIce(2) = TemperatureIce2m
Alias TemperatureIce(3) = TemperatureIce3m
Alias TemperatureIce(4) = TemperatureIce4m
Alias TemperatureIce(5) = TemperatureIce5m
Alias TemperatureIce(6) = TemperatureIce6m
Alias TemperatureIce(7) = TemperatureIce7m
Alias TemperatureIce(8) = TemperatureIce10m
Public TiltX                  ' by NS25/E2
Public TiltY                  ' by NS25/E2
Public TemperatureLogger
Public Currents(4)            ' Current measurements 1,2,4 are not performed in the Promice 2008&09 configuration
Alias Currents(1) = BatteryCurrent
Alias Currents(2) = SolarPanelCurrent
Alias Currents(3) = FanCurrent
Alias Currents(4) = TxGPSCurrent
Public VoltageBatteries       ' the final battery voltage after the measurement scan and before switching off the fan

Public ParseStr(18) As String * 15
Alias ParseStr(1) = GPGGA
Alias ParseStr(2) = TimeGPS
Alias ParseStr(3) = Latitude
Alias ParseStr(4) = HemisphereNS
Alias ParseStr(5) = Longitude
Alias ParseStr(6) = HemisphereEW
Alias ParseStr(7) = Quality
Alias ParseStr(8) = NumberSatellites
Alias ParseStr(9) = HDOP
Alias ParseStr(10) = Altitude
Alias ParseStr(11) = AltitudeUnit
Alias ParseStr(12) = Giodal
Alias ParseStr(13) = GeoUnit 
Alias ParseStr(14) = Age
Alias ParseStr(15) = Difref
Alias ParseStr(16) = Asterisk
Alias ParseStr(17) = Chcksum
Alias ParseStr(18) = CRLF

Units AirPressure=hPa
Units Temperature=C
Units Temperature2=C
Units RelativeHumidity=%
Units WindSpeed=m/s
Units WindDirection=degrees
Units ShortwaveRadiationIn=Vx10^-5
Units ShortwaveRadiationOut=Vx10^-5
Units LongwaveRadiationIn=Vx10^-5
Units LongwaveRadiationOut=Vx10^-5
Units TemperatureRadSensor=C
Units SnowHeight=m
Units SurfaceHeight=m
Units IceHeight=mV
Units TemperatureIce1m=C
Units TemperatureIce2m=C
Units TemperatureIce3m=C
Units TemperatureIce4m=C
Units TemperatureIce5m=C
Units TemperatureIce6m=C
Units TemperatureIce7m=C
Units TemperatureIce10m=C
Units TiltX=Vx10^-2
Units TiltY=Vx10^-2
Units TemperatureLogger=C
Units FanCurrent=mA
Units VoltageBatteries=V

Public FastScanMode As Boolean    ' Use this as a flag to enter/exit fast scan mode
Public FastScanSwitch As Boolean
Public FastScanCount
Public LastFastScan

Public VoltageBatteriesIni
Units VoltageBatteriesIni=V
Public WinterDataTerminator As String *3
Public SummerDataTerminator As String *3
Public InstantDataTerminator As String *3
Public DiagnDataTerminator As String *3
Public TxAllowed As Boolean
Public FanPowerDueForSwOff As Boolean
Public TableInstantaneousString As String * 300
Public TxPowerDueForSwOff As Boolean
Public GarminInitOk As Boolean
Public ConfigFile_H As Long
Public ConfigArrayIT
'Public DiagInfieldWarning As Boolean'check for it not being set before field deployment. It alerts about serious misconigurations, test/debug -only modes being active, ...
Public NGPSFLAG As Boolean
Public GGPSFLAG As Boolean
Public ForceTX As Boolean
Public LoggerOSrev
Public TimersUnit
Public TimersUnitMult
Public Diag
Public SkippedScans
Public SkippedSlowScans1, SkippedSlowScans2
Public GPSinUse As String * 1
Public TimeSince12Von
Public TimeSinceVx3on
Public LastSuccessfulMOMSN
Public SendRecordBacklog
Public SendRecordIT
Public TxTimeTaken
Public TxSendAttempts
Public TxTimeoutTimer
Public TxInitilizeAttempt
Public SBDIoffset
Public SBDIsentence As String * 40
Public SBDIparsed(6) As String * 10
Public SBDsession As Boolean
Public TxInitializeOk As Boolean
Public StrIndex
Public TxSendSuccess As Boolean
Public SentWithSuccess
Public TxMObuffCleared As Boolean
Public TxMOuploaded As Boolean
Public TxRSSI' As String
Public TxSvcAvail As Boolean
Public TxNotifyON As Boolean
Public RS232EchoOk As Boolean
Public TxTypeNAL960x As Boolean
Public TxTypeNAL9601DGSLP As Boolean
Public TxTypeNAL9602LP as Boolean
Public TxModuleATok As Boolean
Public TxModuleRFon As Boolean
Public TxModuleReply As String * 41
'Public TxSerialBuffer As String * 401'set as needed
'Public TxPowerOn As Boolean
Public ResetTxBufferTableDue As Boolean
Public TxModuleGPSPowerOn As Boolean
Public TxBufferString As String * TxStringMaxLen+1+90
Public TxStringUnstripped As String * TxStringMaxLen+1+90
Public TxString As String * TxStringMaxLen+1
Public StringStripperIT
Public StripStringStart
Public StringChar As String * 1
Public MeasCycleDone As Boolean
Public C5status 'As Boolean
Public C5statusPrev 'As Boolean
Public temp 'WARNING! this is used as a temporary variable in many different parts of the code. Always set it explicitly right before use!
Public MPFLAG As Boolean
Public MinutesInYear As Long
Public RTime(9) 'WARNING! this is used as a temporary variable in many different parts of the code. Always set it explicitly right before use!
Alias rTime(1) = Year
Alias rTime(2) = Month
Alias rTime(3) = DayOfMonth
Alias rTime(4) = Hour
Alias rTime(5) = Minute
Alias rTime(6) = Second
Alias rTime(7) = uSecond
Alias rTime(8) = WeekDay
Alias rTime(9) = DayOfYear
Public NewClock(7)
Public GPSTimeStr(3) As String * 3
Public GPSTime(3)
Alias GPSTime(1) = GPShour
Alias GPSTime(2) = GPSminute
Alias GPSTime(3) = GPSsecond
Public ValidGPStime As Boolean
Public Clock2GPSOffset As Long
Public GPSmessageTimer
Public IsSummer As Boolean
Public Low_Batt As Boolean
Public Asp_fan_on As Boolean
Public Aspirated_meas As Boolean
Public temptemp,temptemptemp
Public temp1 ''remove then
Dim SW12Von As Boolean
Public _MUXRES 
Dim MUXCLK As Boolean
Dim it'WARNING! this is used as a temporary variable in many different parts of the code. Always set it explicitly right before use!
Public BestHDOPseen
Public sBestHDOPseen
Public GPGGAsentence As String * 72
Public PreParseStr(18) As String * 15
Alias PreParseStr(7) = PreQual
Alias PreParseStr(9) = PreHDOP
Public PreQual_FP
Public PreHDOP_FP
Public ParseStrIT

'added for binary transmission MCIT 22-4-2009
Public TimeStampSeconds As Long

Public BinFuncIt, StriValueIt
Public DecimalFPNumber
Public InternalDecimalFPNumber
Public NormDecimalNumber
Public GFP2bits(16)
Public GFP2sign, GFP2exp, GFP2normexp, GFP2mant As Long
Public remainder,UnsignizedDecimalNumber,ShiftedDecimalNumber As Long
Public GFP2normalized As Boolean
Public GFP2msb As Long
Public GFP2lsb As Long
Public GFP2string As String * 2

Public DecimalLINumber As Long
Public InternalDecimalLINumber As Long
Public GLI4Bytes(4) As Long
Public GLI4string As String * 4

Public SplittedTXstring(TxStringMaxLen/2+1) As String * 20
Public BinaryTxString As String * 200
Public BinaryTxArray(TxStringMaxLen) As Long
Public BinaryTxArrayPointer As Long
Public ReadableTxString As String * TxStringMaxLen+1
Public StringLong As String * 20
Public LongLong As Long
Public StringLongInt As String * 20
Public TxStringLen
Public testcmd As String * 20
Public BinaryTxFormatPrefix As String * 2
Public BinaryTxSubformatNumber As Long
Public SerialOutBlockIt

Public ChecksumIt
Public BinaryTxStringSum As Long
Public BinaryTxStringChecksum As String * 2

Public dbg_trace_sig As String * 80
Public dbg_trace_sig_bak As String * 80

Public alternativeSR50Address1 As Long
Public alternativeSR50Address2 As Long

' Data Tables -----------------------------------------------------------------------------------------------------

DataTable(TableMem,True,288) ' aka just 2 days of full 10 minutes records in the internal memory - MCIT 06/2012
	DataInterval(0,MemSaveRate*ScanRate,Sec,0) 'now always save a timestamp (card mem is plenty) so no more lapse limits - MCIT 06/2012
	'CardOut(0, -1)'use entire card as usual
	CardOut(0, INT(3600*24*365*CardYears/(MemSaveRate*ScanRate))) 'use only enough card to store CardYears years of data (calculations in seconds)
  Sample(1,MinutesInYear,Long)
	Average(1,AirPressure,IEEE4,False)
	Average(1,Temperature,IEEE4,False)
	Average(1,Temperature2,IEEE4,False)
	Average(1,RelativeHumidity,IEEE4,False)
	WindVector(1,WindSpeed,WindDirection,FP2,False,0,0,0)
	FieldNames("WindSpeed,WindDirection,WindDirection_SD")
  Average(1,ShortwaveRadiationIn,IEEE4,False)
  Average(1,ShortwaveRadiationOut,IEEE4,False)
  Average(1,LongwaveRadiationIn,IEEE4,False)
  Average(1,LongwaveRadiationOut,IEEE4,False)
  Average(1,TemperatureRadSensor,IEEE4,False)
	Sample(1,SnowHeight,FP2)
	Sample(1,SnowHeightQuality,FP2)
	Sample(1,SurfaceHeight,FP2)
	Sample(1,SurfaceHeightQuality,FP2)
	Average(1,IceHeight,FP2,False)
	Average(8,TemperatureIce(),IEEE4,False)
'	FieldNames("TemperatureIce1m,TemperatureIce2m,TemperatureIce3m,TemperatureIce4m,TemperatureIce5m,TemperatureIce6m,TemperatureIce7m,TemperatureIce10m,") 
	Average(1,TiltX,FP2,False)
	Average(1,TiltY,FP2,False)
	Sample(1,TimeGPS,String)
	Sample(1,Latitude,String)
	Sample(1,Longitude,String)
	Sample(1,Altitude,String)
	Sample(1,Giodal,String)
	Sample(1,GeoUnit,String)
	Sample(1,Quality,String)
	Sample(1,NumberSatellites,String)
	Sample(1,HDOP,String)
  Average(1,TemperatureLogger,IEEE4,False)
	Average(1,Currents(3),FP2,False)
'	FieldNames("FanCurrent")
	Sample(1,VoltageBatteriesIni,IEEE4)
 	Sample(1,VoltageBatteries,IEEE4)
EndTable

DataTable(SlimTableMem,True,-1)
	DataInterval(0,SlimMemSaveRate*ScanRate,Sec,0)  'always save a timestamp so no more risks of exceeding lapse limits - MCIT 06/2012
  Sample(1,MinutesInYear,Long)
	Average(1,AirPressure,FP2,False)
	Average(1,Temperature,FP2,False)
	Average(1,Temperature2,FP2,False)
	Average(1,RelativeHumidity,FP2,False)
	WindVector(1,WindSpeed,WindDirection,FP2,False,0,0,0)
	FieldNames("WindSpeed,WindDirection,WindDirection_SD")
  Average(1,ShortwaveRadiationIn,FP2,False)
  Average(1,ShortwaveRadiationOut,FP2,False)
  Average(1,LongwaveRadiationIn,FP2,False)
  Average(1,LongwaveRadiationOut,FP2,False)
  Average(1,TemperatureRadSensor,FP2,False)
	Sample(1,SnowHeight,FP2)
	Sample(1,SnowHeightQuality,FP2)
	Sample(1,SurfaceHeight,FP2)
	Sample(1,SurfaceHeightQuality,FP2)
	Average(1,IceHeight,FP2,False)
	Average(8,TemperatureIce(),FP2,False)
'	FieldNames("TemperatureIce1m,TemperatureIce2m,TemperatureIce3m,TemperatureIce4m,TemperatureIce5m,TemperatureIce6m,TemperatureIce7m,TemperatureIce10m,") 
	Average(1,TiltX,FP2,False)
	Average(1,TiltY,FP2,False)
	Sample(1,TimeGPS,String)
	Sample(1,Latitude,String)
	Sample(1,Longitude,String)
	Sample(1,Altitude,String)
	Sample(1,Giodal,String)
	Sample(1,GeoUnit,String)
	Sample(1,Quality,String)
	Sample(1,NumberSatellites,String)
	Sample(1,HDOP,String)
  Average(1,TemperatureLogger,FP2,False)
	Average(1,Currents(3),FP2,False)
'	FieldNames("FanCurrent")
	Sample(1,VoltageBatteriesIni,FP2)
 	Sample(1,VoltageBatteries,FP2)
EndTable

DataTable(TableDiagnostics,True,1)'yes, it effectively ends up being 41 due to the 1 kbyte memory frame size - MCIT 6/2012
	DataInterval(0,DiagnosticsRate,hr,0)
	'CardOut(0, -1) 'use entire card as usual
	CardOut(0,INT(24*365*CardYears/DiagnosticsRate))'use only enough card to store CardYears years of data (calculation in hours)
  'Sample(1,status.RevBoard,Uint2)
	Sample(1,status.LithiumBattery,FP2)
	Sample(1,status.Low12VCount,FP2)
	Totalize(1,TxInitializeOk,FP2,False)
	Sample(1,SentWithSuccess,FP2)
	Sample(1,SendRecordBacklog,FP2)
 	Sample(1,DiagnDataTerminator,String)
EndTable

DataTable(TableSummerTx,True,1)
	DataInterval(0,SummerTxRate*ScanRate,Sec,0)
	Average(1,AirPressure,FP2,False)
	Average(1,Temperature,FP2,False)
	Average(1,RelativeHumidity,FP2,False)
	WindVector (1,WindSpeed,WindDirection,FP2,False,0,0,1)  ' Also outputs wind direction variability, which I'd like to see removed
  Average(1,ShortwaveRadiationIn,FP2,False)
  Average(1,ShortwaveRadiationOut,FP2,False)
  Average(1,LongwaveRadiationIn,FP2,False)
  Average(1,LongwaveRadiationOut,FP2,False)
  Average(1,TemperatureRadSensor,FP2,False)
	Sample(1,SnowHeight,FP2)
	Sample(1,SurfaceHeight,FP2)
	Sample(1,IceHeight,FP2)
	Average(8,TemperatureIce(),FP2,False)
	Average(1,TiltX,FP2,False)
	Average(1,TiltY,FP2,False)
	Sample(1,Latitude,String)
	Sample(1,Longitude,String)
	Sample(1,Altitude,String)
 	Sample(1,currents(3),FP2)
 	Sample(1,VoltageBatteries,FP2)
 	Sample(1,SummerDataTerminator,String)
EndTable

DataTable(TableWinterTx,True,1)
	DataInterval(0,WinterTxRate*ScanRate,Sec,0)
	Average(1,AirPressure,FP2,False)
	Average(1,Temperature,FP2,False)
	Average(1,RelativeHumidity,FP2,False)
	WindVector (1,WindSpeed,WindDirection,FP2,False,0,0,1)  ' Also outputs wind direction variability, which I'd like to see removed
  Average(1,ShortwaveRadiationIn,FP2,False)
  Average(1,ShortwaveRadiationOut,FP2,False)
  Average(1,LongwaveRadiationIn,FP2,False)
  Average(1,LongwaveRadiationOut,FP2,False)
  Average(1,TemperatureRadSensor,FP2,False)
	Sample(1,SnowHeight,FP2)
	Sample(1,SurfaceHeight,FP2)
	Sample(1,IceHeight,FP2)
	Average(8,TemperatureIce(),FP2,False)
	Average(1,TiltX,FP2,False)
	Average(1,TiltY,FP2,False)
	Sample(1,Latitude,String)
	Sample(1,Longitude,String)
	Sample(1,Altitude,String)
 	Sample(1,currents(3),FP2)
 	Sample(1,VoltageBatteries,FP2)
 	Sample(1,SummerDataTerminator,String)
EndTable

DataTable(InstantaneousTable,True,1)  ' Table for low-frequent and instantaneous measurements
	Sample(1,AirPressure,FP2)  ' changed from Dirk's unneeded IEEE4 (screws up tx). Dirk: not unneeded! FP2 prints too few decimals to be of use to DMI, especially when p > 1000 hPa
  Sample(1,Temperature,FP2)
	Sample(1,RelativeHumidity,FP2)
 	WindVector (1,WindSpeed,WindDirection,FP2,False,0,0,1)
 	Sample(1,InstantDataTerminator,String)
EndTable
  
DataTable(TxBufferTable,True,SizeTableBuffer)  ' Table to store measurement lines that were not (yet) transmitted
  Sample(1,TxBufferString, String)
EndTable

' Subroutines -----------------------------------------------------------------------------------------------------


Sub DECtoGFP2 (DecimalFPNumber)
  InternalDecimalFPNumber = DecimalFPNumber 'CRBasic function calls are by reference!!!
  'encode the sign bit
  GFP2sign = InternalDecimalFPNumber >= 0
  GFP2bits(1) = -NOT(GFP2sign)
  'encode the exponent, accounting for proper denorms and artifact denorms due to mantissa overflow past 7999
  If NOT GFP2sign Then InternalDecimalFPNumber = -InternalDecimalFPNumber
  If InternalDecimalFPNumber > 7999 Then InternalDecimalFPNumber = 7999
  If InternalDecimalFPNumber < 0.0005 Then
    InternalDecimalFPNumber = 0
    GFP2exp = 0
  Else
    GFP2exp = Floor(LOG10(InternalDecimalFPNumber))
  EndIf
  If GFP2exp < 0 Then
    GFP2normexp = 3
    GFP2normalized = False
  Else
    GFP2normexp = 3 - GFP2exp
    GFP2normalized = True
  EndIf
  If InternalDecimalFPNumber * 10^GFP2normexp > 7999 Then GFP2normexp = GFP2normexp - 1
  If (3-GFP2normexp)>0 Then remainder=3-GFP2normexp Else remainder = 0
  For BinFuncIt = 1 To 0 Step -1
    If remainder >= 2^BinFuncIt Then
      GFP2bits(2 + 1 - BinFuncIt) = 1
      remainder = remainder - 2^BinFuncIt
    Else
      GFP2bits(2 + 1 - BinFuncIt) = 0
    EndIf
  Next
  'encode the normalized or denormalized the mantissa 
  NormDecimalNumber = InternalDecimalFPNumber * 10 ^ GFP2normexp
  If NormDecimalNumber MOD 1 >= 0.5 Then NormDecimalNumber = NormDecimalNumber + 1
  remainder = NormDecimalNumber
  For BinFuncIt = 12 To 0 Step -1
    If remainder >= 2^BinFuncIt Then
      GFP2bits(4 + 12 - BinFuncIt) = 1
      remainder = remainder - 2^BinFuncIt
    Else
      GFP2bits(4 + 12 - BinFuncIt) = 0
    EndIf
  Next
  'produce the msb and lsb bytes
  GFP2msb = 128*GFP2bits(1)+64*GFP2bits(2)+32*GFP2bits(3)+16*GFP2bits(4)+8*GFP2bits(5)+4*GFP2bits(6)+2*GFP2bits(7)+GFP2bits(8)
  GFP2lsb = 128*GFP2bits(9)+64*GFP2bits(10)+32*GFP2bits(11)+16*GFP2bits(12)+8*GFP2bits(13)+4*GFP2bits(14)+2*GFP2bits(15)+GFP2bits(16)
  GFP2string = CHR(GFP2msb) & CHR(GFP2lsb)
EndSub  

Sub DECtoGLI4(DecimalLINumber As Long)
  InternalDecimalLINumber = DecimalLINumber'CRBasic function calls are by reference!!!
  GLI4bytes(1) = (InternalDecimalLINumber AND &H7F000000)/&h01000000
  GLI4bytes(2) = (InternalDecimalLINumber AND &H00FF0000)/&h010000
  GLI4bytes(3) = (InternalDecimalLINumber AND &H0000FF00)/&h0100
  GLI4bytes(4) = (InternalDecimalLINumber AND &H000000FF)
  If DecimalLINumber < 0 Then GLI4bytes(1) = (GLI4bytes(1)) + &h80
  GLI4string = CHR(GLI4bytes(1)) & CHR(GLI4bytes(2)) & CHR(GLI4bytes(3)) & CHR(GLI4bytes(4))
EndSub

Sub StrLongify(StringLong As String * 20, LongLong As Long)
  'Note: this is a crude hack that simply takes out the decimal point, so it requires the input 
  'string to be in a known fixed point format, since StrLongify(12.3) == StrLongify(1.23) = 123
  StringLongInt = Replace(StringLong,".","")
  LongLong = StringLongInt
EndSub

Sub ComputeChecksum
  BinaryTxStringSum = 0
  For ChecksumIt = 1 To TxStringMaxLen-2'-2 prevents indexing out of bounds in the next "if"
    If BinaryTxArray(ChecksumIt + 2) = 999 Then
      ExitFor
    Else
      BinaryTxStringSum = BinaryTxStringSum + BinaryTxArray(ChecksumIt)
    EndIf
  Next
EndSub

Sub BinaryEncode
  ReadableTxString = TxString'ReadableTxString is useless if BinaryEncode will remain unparameterized
  BinaryTxString = ""
  BinaryTxFormatPrefix = ""
  BinaryTxSubformatNumber = BinaryTxFormatID*5
  For StriValueIt = 1 To TxStringMaxLen'would be nicer to get the actual # of fields in the tx table
    If BinaryTxArray(StriValueIt) = 999 Then'end of previous binaryfication results found, no need to go further
      BinaryTxArray(StriValueIt) = 0
      ExitFor
    Else
      BinaryTxArray(StriValueIt) = 0'erasing previous binaryfication results
    EndIf
  Next
  BinaryTxArrayPointer = 1'so that the first ends up in (2), and (1) is set at the end with the format header
  SplitStr(SplittedTXstring(1), TxString, ",", TxStringMaxLen/2+1, 5)
  For StriValueIt = 1 To TxStringMaxLen/2+1 Step 1'note that StriValueIt is also used for iteration above for convenience (should use a better name there)
    If SplittedTXstring(StriValueIt) = "!S" Then
      BinaryTxSubformatNumber = BinaryTxSubformatNumber + 0
    ElseIf SplittedTXstring(StriValueIt) = "!W" Then
      BinaryTxSubformatNumber = BinaryTxSubformatNumber + 2
    ElseIf SplittedTXstring(StriValueIt) = "!I" Then
      BinaryTxSubformatNumber = BinaryTxSubformatNumber + 1
    ElseIf SplittedTXstring(StriValueIt) = "!D" Then
      BinaryTxSubformatNumber = BinaryTxSubformatNumber + 4
    ElseIf SplittedTXstring(StriValueIt) = "!M" Then'the !M terminator MUST be there, or it will all get VERY expensive!
      BinaryTxArray(BinaryTxArrayPointer+3) = 999
      ExitFor
    ElseIf SplittedTXstring(StriValueIt) = "NAN" Then'add uppercase
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = 127
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = 255
    ElseIf SplittedTXstring(StriValueIt) = "INF" Then
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = 127
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = 254
    ElseIf SplittedTXstring(StriValueIt) = "-INF" Then
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = 255
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = 255
    ElseIf Len(SplittedTXstring(StriValueIt)) = 19 Then'timestamp
      TimeStampSeconds = SecsSince1990(SplittedTXstring(StriValueIt),4)
      DecimalLINumber = TimeStampSeconds    
      DECtoGLI4 (DecimalLINumber)
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = GLI4bytes(1)
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = GLI4bytes(2)
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = GLI4bytes(3)
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = GLI4bytes(4)
    ElseIf Left(SplittedTXstring(StriValueIt), 2) = "GT" Then'GPS time. It was: Len(SplittedTXstring(StriValueIt)) = 9 Then
      StringLong = Right(SplittedTXstring(StriValueIt), Len(SplittedTXstring(StriValueIt)) - 2)
      StrLongify(StringLong, LongLong)
      DecimalLINumber = LongLong    
      DECtoGLI4 (DecimalLINumber)
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = GLI4bytes(1)
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = GLI4bytes(2)
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = GLI4bytes(3)
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = GLI4bytes(4)
    ElseIf Left(SplittedTXstring(StriValueIt), 2) = "NH" OR Left(SplittedTXstring(StriValueIt), 2) = "SH" Then'Lat. It was: Len(SplittedTXstring(StriValueIt)) = 10 Then'gps lat
      StringLong = Right(SplittedTXstring(StriValueIt), Len(SplittedTXstring(StriValueIt)) - 2)
      If Left(StringLong, 2) = "SH" Then StringLong = "-" + StringLong
      StrLongify(StringLong, LongLong)
      DecimalLINumber = LongLong    
      DECtoGLI4 (DecimalLINumber)
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = GLI4bytes(1)
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = GLI4bytes(2)
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1 
      BinaryTxArray(BinaryTxArrayPointer) = GLI4bytes(3)
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = GLI4bytes(4)
    ElseIf Left(SplittedTXstring(StriValueIt), 2) = "EH" OR Left(SplittedTXstring(StriValueIt), 2) = "WH" Then'Lon. It was: Len(SplittedTXstring(StriValueIt)) = 11 Then'gps lon
      StringLong = Right(SplittedTXstring(StriValueIt), Len(SplittedTXstring(StriValueIt)) - 2)
      If Left(StringLong, 2) = "WH" Then StringLong = "-" + StringLong
      StrLongify(StringLong, LongLong)
      DecimalLINumber = LongLong    
      DECtoGLI4 (DecimalLINumber)
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = GLI4bytes(1)
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = GLI4bytes(2)
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = GLI4bytes(3)
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = GLI4bytes(4)
    ElseIf Len(SplittedTXstring(StriValueIt)) <= 6 AND SplittedTXstring(StriValueIt)<>"" Then'<=6 is ugly and requires no Long is programmed in the Tx tables
      DecimalFPNumber = SplittedTXstring(StriValueIt)
      DECtoGFP2 (DecimalFPNumber)
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = GFP2msb
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = GFP2lsb
    Else' if it doesn't understand, then encode it as a NAN
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = 127
      BinaryTxArrayPointer = BinaryTxArrayPointer + 1
      BinaryTxArray(BinaryTxArrayPointer) = 255
     EndIf
  Next
  If BinaryTxSubformatNumber >= 48 Then BinaryTxSubformatNumber = BinaryTxSubformatNumber + 10'to skip ASCII numerals
  BinaryTxArray(1) = BinaryTxSubformatNumber
  ComputeChecksum
  BinaryTxArray(BinaryTxArrayPointer + 1) = (BinaryTxStringSum MOD 65536)/256'need not to increase the pointer
  BinaryTxArray(BinaryTxArrayPointer + 2) = (BinaryTxStringSum MOD 256)'because it will be used as length of the binary data
EndSub

Sub TxModuleInit
  dbg_trace_sig=dbg_trace_sig+"[I0"'''''''''''''''''''''''''''''''''''''
  If NOT (SummerTxRate OR WinterTxRate OR (GPSType="N")) Then ExitSub
  TxInitializeOk = False
  If NOT TxInitializeOk Then'redundant?!?
    SerialOpen(ComRS232,19200,0,0,400)
    SerialOut(ComRS232,"A","",25,20)' to allow 5 secs for the Iridium Module to start listening to the serial bus
    dbg_trace_sig=dbg_trace_sig+"1"'''''''''''''''''''''''''''''''''''''
    For TxInitilizeAttempt = 1 To TxMaxInitAttempts
      SerialOut(ComRS232,"TE1"+CHR(13)+CHR(10),"",1,10) 'should be default but doesn't hurt...
      If SerialOut(ComRS232,"ATV1"+CHR(13)+CHR(10),"OK",1,10) Then RS232EchoOk = True Else RS232EchoOk = False
      If SerialOut(ComRS232,"AT"+CHR(13)+CHR(10),"OK"+CHR(13)+CHR(10),1,10) Then TxModuleATok = True Else TxModuleATok = False
      If SerialOut(ComRS232,"ATI4"+CHR(13)+CHR(10),"IRIDIUM 9600 Family"+CHR(13)+CHR(10),1,10) Then TxTypeNAL960x = True Else TxTypeNAL960x = False
      If SerialOut(ComRS232,"ATI4"+CHR(13)+CHR(10),"NAL Research Corporation 9601-DGS-LP"+CHR(13)+CHR(10),1,10) Then TxTypeNAL9601DGSLP = True Else TxTypeNAL9601DGSLP = False
      If SerialOut(ComRS232,"ATI4"+CHR(13)+CHR(10),"NAL Research Corporation: 9602-LP"+CHR(13)+CHR(10),1,10) Then TxTypeNAL9602LP = True Else TxTypeNAL9602LP = False
      'If NOT (TxTypeNAL960x OR TxTypeNAL9601DGSLP) Then TxTypeNAL9601DGSLP'who trusts NAL? Just pretend it is the new model if we don't know any better...
      If TxModuleATok AND RS232EchoOk AND (TxTypeNAL960x OR TxTypeNAL9601DGSLP OR TxTypeNAL9602LP) Then 'FIXME!! 
        dbg_trace_sig=dbg_trace_sig+"2"'''''''''''''''''''''''''''''''''''''
        TxInitializeOk = True
        ExitFor
      Else
        TxInitializeOk = False
      EndIf
    Next
    dbg_trace_sig=dbg_trace_sig+"3]"'''''''''''''''''''''''''''''''''''''
    SerialClose(ComRS232)
  EndIf
EndSub

Sub IridiumTx
  dbg_trace_sig=dbg_trace_sig+"[T0"'''''''''''''''''''''''''''''''''''''
  If NOT (SummerTxRate OR WinterTxRate OR (GPSType="N")) Then
    dbg_trace_sig=dbg_trace_sig+")"'''''''''''''''''''''''''''''''''''''
    ExitSub
  EndIf
  
  If TransmitBinary = True Then Call BinaryEncode'move after initializtion after debugging

  Call TxModuleInit
  If NOT TxInitializeOk Then
    dbg_trace_sig=dbg_trace_sig+")"'''''''''''''''''''''''''''''''''''''
    SerialClose(ComRS232)
    ExitSub
  EndIf

  SerialOpen(ComRS232,19200,0,0,400)
  If TxTypeNAL9601DGSLP OR TxTypeNAL9602LP Then 'the old and new Iridium things from NAL have different syntax
    If SerialOut(ComRS232,"AT*S1"+CHR(13)+CHR(10),"OK"+CHR(13)+CHR(10),1,300) Then TxModuleRFon = True Else TxModuleRFon = False
  EndIf
  If TxTypeNAL960x Then 'the old and new Iridium things from NAL have different syntax
    If SerialOut(ComRS232,"AT*S=1"+CHR(13)+CHR(10),"OK"+CHR(13)+CHR(10),1,300) Then TxModuleRFon = True Else TxModuleRFon = False
  EndIf
  If TxTypeNAL9601DGSLP OR TxTypeNAL9602LP Then'this version is more robust, but is untested on the old NAL devices. Test and then backport if possible
    If SerialOut(ComRS232,"AT+SBDD0"+CHR(13)+CHR(10),CHR(13)+CHR(10)+"0"+CHR(13)+CHR(10)+CHR(13)+CHR(10)+"OK"+CHR(13)+CHR(10),1,100) Then TxMObuffCleared = True Else TxMObuffCleared = false
  EndIf
  If TxTypeNAL960x Then'this is not as robust because the 0 echoed from the AT+SBDD0 will be mistaken for the result code, but it has always worked with the old 9601 units
    If SerialOut(ComRS232,"AT+SBDD0"+CHR(13)+CHR(10),"0",1,100) Then TxMObuffCleared = True Else TxMObuffCleared = false
  EndIf
  dbg_trace_sig=dbg_trace_sig+"1"'''''''''''''''''''''''''''''''''''''
  If TransmitBinary = False Then
    If SerialOut(ComRS232,"AT+SBDWT"+CHR(13)+CHR(10),"READY" + CHR(13) + CHR(10), 1, 10) Then
      SerialOutBlock (ComRS232,TxString+CHR(13),Len(TxString)+10)
      If SerialOut(ComRS232,"","0"+CHR(13)+CHR(10),1,100) Then TxMOuploaded = True Else TxMOuploaded = False 'NOTE the somewhat weird use of SerialOut
    EndIf
  Else
    testcmd = "AT+SBDWB"+CHR(13)+CHR(10)&BinaryTxArrayPointer
    If SerialOut(ComRS232,"AT+SBDWB="+BinaryTxArrayPointer+CHR(13)+CHR(10),"READY" + CHR(13) + CHR(10), 1, 200) Then
      dbg_trace_sig=dbg_trace_sig+"2"'''''''''''''''''''''''''''''''''''''
      For SerialOutBlockIt = 1 To BinaryTxArrayPointer + 2
        SerialOutBlock (ComRS232,CHR(BinaryTxArray(SerialOutBlockIt)),1)
      Next
      dbg_trace_sig=dbg_trace_sig+"3"'''''''''''''''''''''''''''''''''''''
      If SerialOut(ComRS232,"","0"+CHR(13)+CHR(10),1,100) Then TxMOuploaded = True Else TxMOuploaded = False 'NOTE the somewhat weird use of SerialOut
      dbg_trace_sig=dbg_trace_sig+"4"'''''''''''''''''''''''''''''''''''''
    Else
      dbg_trace_sig=dbg_trace_sig+"!"'''''''''''''''''''''''''''''''''''''      
    EndIf
  EndIf
      
  If NOT (TxMObuffCleared AND TxMOuploaded AND TxModuleRFon) Then
    dbg_trace_sig=dbg_trace_sig+")"'''''''''''''''''''''''''''''''''''''      
    SerialClose(ComRS232)
    ExitSub
  EndIf
  
'  set like this instead if a failed tx blocks all subsequent transmissions.
'  If NOT (TxMObuffCleared AND TxModuleRFon) Then
'    SerialClose(ComRS232)
'    ExitSub
'  EndIf

  Timer(1,sec,2)'TIMER 1 is only used for the IridiumTX timeout
  Do
    TxTimeoutTimer = Timer(1,sec,4)
    If TxTimeoutTimer >= TxTimeout Then 'the = is needed because the timer has a corse one-second reslution
      dbg_trace_sig=dbg_trace_sig+")"'''''''''''''''''''''''''''''''''''''
      Timer(1,sec,3)
      SerialClose(ComRS232)
      ExitSub
    EndIf
    SerialFlush(ComRS232)
    If SerialOut(ComRS232,"AT+CIER=1,1,1,0"+CHR(13)+CHR(10),"OK"+CHR(13)+CHR(10),1,10) Then TxNotifyON = True Else TxNotifyON = False
    dbg_trace_sig=dbg_trace_sig+"5"'''''''''''''''''''''''''''''''''''''
    Do
      TxTimeoutTimer = Timer(1,sec,4)
      If TxTimeoutTimer >= TxTimeout Then 'the = is needed because the timer has a corse one-second resolution
        dbg_trace_sig=dbg_trace_sig+")"'''''''''''''''''''''''''''''''''''''
        Timer(1,sec,3)
        SerialClose(ComRS232)
        ExitSub
      EndIf
      SerialIn(TxModuleReply,ComRS232, TxTimeout*100, CHR(13)+CHR(10),15)' put here a timeout waiting for service availability
      If InStr(1,TxModuleReply,"+CIEV:0,",4) Then TxRSSI = Mid(TxModuleReply, InStr(1,TxModuleReply,"+CIEV:0,",4), 1)
      If InStr(1,TxModuleReply,"+CIEV:1,",4) Then TxSvcAvail = Mid(TxModuleReply, InStr(1,TxModuleReply,"+CIEV:1,",4) , 1)
    Loop Until TxSvcAvail AND TxRSSI > 0
    dbg_trace_sig=dbg_trace_sig+"6"'''''''''''''''''''''''''''''''''''''
    If SerialOut(ComRS232,"AT+CIER=0,1,1,0"+CHR(13)+CHR(10),"OK"+CHR(13)+CHR(10),1,10) Then TxNotifyON = False Else TxNotifyON = True
    SerialFlush(ComRS232)
    If NOT TxAllowed Then ExitDo
    TxSendAttempts=TxSendAttempts+1
    SBDsession = True'\
    SerialOut(ComRS232,"AT+SBDI"+CHR(13),"",1,10)
    SerialOut(ComRS232,"","+SBDI:",1,6000)' WAIT up to 1 minute for the outcome of the SBD session
    SerialIn(TxModuleReply,ComRS232, 0, 13, 40)
    SplitStr(SBDIparsed(1),TxModuleReply,CHR(44),6,0)
    If SBDIparsed(1)="1" AND SBDIparsed(2) <> LastSuccessfulMOMSN Then
      TxSendSuccess = True
      SentWithSuccess = SentWithSuccess + 1
      LastSuccessfulMOMSN = SBDIparsed(2)
    Else
      TxSendSuccess = False
      TxSvcAvail = false
      TxRSSI = 0
    EndIf  
    SBDsession = False'\
  Loop Until TxSendSuccess' actually, it keeps trying for no longer than TxTimeout
  dbg_trace_sig=dbg_trace_sig+"7]"'''''''''''''''''''''''''''''''''''''
  TxTimeTaken = TxTimeoutTimer
  Timer(1,sec,3)
  SerialClose(ComRS232)
EndSub

' Main Program ----------------------------------------------------------------------------------------------------
BeginProg
 
  'light the LED for 2 seconds ("main program started")
  PortSet(5,true)
  Delay(0,500,msec)
  PortSet(5,false)

  Low_Batt = True              ' Will be cleared after the first scan if battery is ok. Prevents starting fan & Tx of an almost dead station that rebooted automatically
  FastScanMode = False
  FastScanCount = FastScanReps
  IsSummer = False
  TxAllowed = True
  ResetTxBufferTableDue = False

  WinterDataTerminator="!W"
  SummerDataTerminator="!S"
  InstantDataTerminator="!I"
  DiagnDataTerminator="!D"
  
  LoggerOSrev = Right(Status.OSVersion,2)' it assumes that Cambell will keep numbering their releases in a consistent format
  If LoggerOSrev < 14 Then TimersUnitMult = 1000000 Else TimersUnitMult = 1'Here we work around the buggy Timer() function in CR1000 OS system prior to rev. 14
  
	Battery(VoltageBatteriesIni)
	
  GPSinUse = UpperCase(GPSType)
	BestHDOPseen = 100
	sBestHDOPseen = 100
	
	TxInitializeOk=False	
	PortGet(C5status,8)
  'com2 an the following line must not be used starting from promice2014a (com2 is now used as SDI port 3 and 4 for the two SR50.
  'SerialOpen(com2,GarminBaudRate,0,0,1000)'due to a possible bug in the CR1000 OS, if this gets opened anywhere else the logger will never enter sleep mode


Scan(FastScanRate,Sec,1,0)
  If dbg_trace_sig="" Then dbg_trace_sig_bak="~"+dbg_trace_sig_bak Else dbg_trace_sig_bak = dbg_trace_sig
  dbg_trace_sig = ""

  PulsePort(5,10000)'blink the led
    
    'Excites Vx3 to allow the NT1400 to thermally stabilize
  If (TimeIntoInterval(0,ScanRate,sec) OR FastScanMode) Then
    ExciteV(Vx3,2500,0)
    Timer(3,sec,2)' TIMER 3 is used to keep track of how long the Vx3 excitation has been excited
  	TimeSinceVx3on = Timer(3,sec,4)
  Else
    Timer(3,sec,3)'we won't need to also switch Vx3 off explicitly: it is done automatically.
  EndIf

  If FastScanMode AND FastScanCount = 0 Then FastScanCount = FastScanReps
  If NOT FastScanMode AND FastScanCount > 0 Then FastScanCount = 0
	If FastScanMode AND FastScanCount > 0 Then FastScanCount = FastScanCount - 1
	If FastScanMode AND FastScanCount = 0 Then LastFastScan = True
	If FastScanMode AND FastScanCount = 0 Then FastScanMode = False
		
    'Starts the Rotronics aspirated shield fan      
  If VoltageBatteries >= LongerFanBattThre Then'NOTE: the advance interval is controlled by the final voltage of the previous measurement scan
    If (TimeIntoInterval(ScanRate-LongerAdvanceFanStart*FastScanRate,ScanRate,sec) OR FastScanMode) Then
   		If VoltageBatteriesIni = -999 Then Battery(VoltageBatteriesIni)
    	If NOT Low_Batt Then
         PortSet(8,true)
         Asp_fan_on = True
      EndIf
    EndIf
  Else
    If (TimeIntoInterval(ScanRate-AdvanceFanStart*FastScanRate,ScanRate,sec) OR FastScanMode) Then
   		If VoltageBatteriesIni = -999 Then Battery(VoltageBatteriesIni)
    	If NOT Low_Batt Then
         PortSet(8,true)
         Asp_fan_on = True
      EndIf
    EndIf
  EndIf
'2010-07-17 16:00:00,1015,NAN,-17,-7.769,0,0,0,609.5,77.44,-96.4,48.71,30.63,!S,NAN,NAN,-0.169,-108.9,-108.9,-108.9,-108.9,-108.9,-108.9,-108.9,-108.9,0.017,-0.349,GT135006.00,NH5541.32138,EH01234.89967,18.1,1.55,-0.802,12.68,1015,NAN,-6.194,0,0,0,!I,!M
    'if needed, it powers up the Tx module and initializes its integrated GPS receiver, disabling the Iridium RF section to save power
  If (GPSinUse = "G" OR GPSinUse = "N") Then
  	If NOT Low_Batt Then
      If IsSummer Then'TODO: rewrite without this ugly repetition
        If (TimeIntoInterval(SummerGPSrate*ScanRate-AdvanceGPSstart,SummerGPSrate*ScanRate,sec) OR FastScanMode) AND NOT TxModuleGPSPowerOn Then
          dbg_trace_sig=dbg_trace_sig+"[G0"'''''''''''''''''''''''''''''''''''''
       		If VoltageBatteriesIni = -999 Then Battery(VoltageBatteriesIni)
          'If (GPSinUse = "G") Then  'cannot use anymore starting from 2014a   
          '  PortSet(6,True)
          '  TxModuleGPSPowerOn = True
          '  'SerialFlush(Com2) 'cannot use anymore starting from 2014a
          '  GPGGAsentence=""
          '  'SerialIn (GPGGAsentence,COM2,GarminWarmup * 100,-1,10) 'cannot use anymore starting from 2014a           
          '  If Len(GPGGAsentence)>0 Then
          '    GarminInitOk = True
          '  Else
          '    GarminInitOk = False
          '  EndIf
          'EndIf
          If (GPSinUse = "N") Then
            dbg_trace_sig=dbg_trace_sig+"1"'''''''''''''''''''''''''''''''''''''
            temptemp=temptemp+1
            PortSet(6,True)
            TxModuleGPSPowerOn = True
            SerialOpen(ComRS232,19200,0,0,100)
            SerialFlush(ComRS232)
            Call TxModuleInit
            If TxInitializeOk Then
              If TxTypeNAL9601DGSLP Then 'the old and new Iridium things from NAL have different syntax...
                dbg_trace_sig=dbg_trace_sig+"2]"'''''''''''''''''''''''''''''''''''''
                SerialOut(ComRS232,"AT*S0"+CHR(13)+CHR(10),"",1,10)'shut down the Iridium radio - asap after powerup
                'now try to disable the crappy workaround that NAL put in the new devices to prevent them
                'from hanging their own GPSs... AT^GRS is not documented in the docs, only in the firmware
                'change log file, and in any case doesn't work entirely as described, since the first sleep-wake
                'cycle is done anyway! Problem is, it falls asleep in the middle of a command (see analyzer traces
                '#4,5,7,8, and then all the stupid bla-bla message is output with no regard for the return values
                'of any function that may be running, corrupting them. 180 sec is as good a number as any other,
                'in hope it keeps the bla-bla out of the way...
                SerialOut(ComRS232,"AT^GRS=0,0"+CHR(13)+CHR(10),"",1,10)
              EndIf
              If TxTypeNAL9602LP Then
                dbg_trace_sig=dbg_trace_sig+"2]"'''''''''''''''''''''''''''''''''''''
                SerialOut(ComRS232,"AT*S0"+CHR(13)+CHR(10),"",1,10)
                'the newest 9602 doesn't have the AT^GRS command that was required for the 9601DGSLP
              EndIf
              If TxTypeNAL960x Then 'the old and new Iridium things from NAL have different syntax...
                SerialOut(ComRS232,"AT*S=0"+CHR(13)+CHR(10),"",1,10)'shut down the Iridium radio - asap after powerup
              EndIf
              SerialOut(ComRS232,"AT+PP=1"+CHR(13)+CHR(10),"",1,10)'power up the GPS - asap after powerup
              SerialOut(ComRS232,"AT+PNAV=1"+CHR(13)+CHR(10),"",1,10)'tell the GPS kalman filter that it's static - asap after powerup
              SerialClose(ComRS232)
            EndIf
          EndIf
          If NOT(GarminInitOk OR TxInitializeOk) Then
            TxPowerDueForSwOff = True
          EndIf
        EndIf
      Else'else it is winter
        If (TimeIntoInterval(WinterGPSrate*ScanRate-AdvanceGPSstart,WinterGPSrate*ScanRate,sec) OR FastScanMode) AND NOT TxModuleGPSPowerOn Then
     	  	If VoltageBatteriesIni = -999 Then Battery(VoltageBatteriesIni)
          'If (GPSinUse = "G") Then  'cannot use anymore starting from 2014a   
          '  PortSet(6,True)
          '  TxModuleGPSPowerOn = True
          '  'SerialFlush(Com2)'cannot use anymore starting from 2014a
          '  GPGGAsentence=""
          '  'SerialIn (GPGGAsentence,COM2,GarminWarmup * 100,-1,10)   'cannot use anymore starting from 2014a         
          '  If Len(GPGGAsentence)>0 Then
          '    GarminInitOk = True
          '  Else
          '    GarminInitOk = False
          '  EndIf
          'EndIf
          If (GPSinUse = "N") Then
            temptemp=temptemp+1
            PortSet(6,True)
            TxModuleGPSPowerOn = True
            SerialOpen(ComRS232,19200,0,0,100)
            SerialFlush(ComRS232)
            Call TxModuleInit
            If TxInitializeOk Then
              If TxTypeNAL9601DGSLP Then 'the old and new Iridium things from NAL have different syntax...
                SerialOut(ComRS232,"AT*S0"+CHR(13)+CHR(10),"",1,10)'shut down the Iridium radio - asap after powerup
              EndIf
              If TxTypeNAL9602LP Then
                dbg_trace_sig=dbg_trace_sig+"2]"'''''''''''''''''''''''''''''''''''''
                SerialOut(ComRS232,"AT*S0"+CHR(13)+CHR(10),"",1,10)
                'the newest 9602 doesn't have the AT^GRS command that was required for the 9601DGSLP
              EndIf
              If TxTypeNAL960x Then 'the old and new Iridium things from NAL have different syntax...
                SerialOut(ComRS232,"AT*S=0"+CHR(13)+CHR(10),"",1,10)'shut down the Iridium radio - asap after powerup
              EndIf
              SerialOut(ComRS232,"AT+PP=1"+CHR(13)+CHR(10),"",1,10)'power up the GPS - asap after powerup
              SerialOut(ComRS232,"AT+PNAV=1"+CHR(13)+CHR(10),"",1,10)'tell the GPS kalman filter that it's static - asap after powerup
              SerialClose(ComRS232)
            EndIf
          EndIf
          If NOT(GarminInitOk OR TxInitializeOk) Then
            TxPowerDueForSwOff = True
          EndIf
        EndIf
      EndIf
    EndIf
  EndIf
   
 'Executes the measurements *******************************************************************************
 '*********************************************************************************************************
'	If VoltageBatteriesIni = -999 Then Battery(VoltageBatteriesIni)'moved 2 lines down MCIT 16/7/2010
	
  If (FastScanMode AND FastScanCount > 0) OR TimeIntoInterval(0,ScanRate,sec) Then
   	If VoltageBatteriesIni = -999 Then Battery(VoltageBatteriesIni)
 		SW12(True)'Enabling switched 12V supply
 		SW12Von = True
    Timer(2,sec,2)' TIMER 2 is used to keep track of how long the SW12V has been ON
   	TimeSince12Von = Timer(2,sec,4)

	  ' Wiring Panel Temperature measurement
		PanelTemp(TemperatureLogger,_50Hz)
		ExciteV(Vx3,2500,0)'This MUST be right after any bridge, P107 and PanelTemp preceding the NT1400 measure

    ' Determining whether it's summer or winter
 		RealTime(RTime)
	  If DayOfYear >= BeginOfSummer AND DayOfYear < BeginOfWinter Then IsSummer = True Else IsSummer = False'don't remove the else block or it won't switch back to winter!!
    
   'do now whatever needs the 12V switched supply to be ON but doesn't use the MUX and does NOT require warm-up

   'Enables the MUX by bringing its _RES input high and then explicitly resets the MUX
	  PortSet(1,1)  'brings the _RES input on the MUX high (means the MUX is in operational status)
	  Delay(0,1,sec)'waits for the MUX to be fully awake after SW12V came up and _RES went high (from tests: don't remove!!)
	  PulsePort(1,20000)  'pulses low the _RES input on the MUX for 20 ms
		
		'advances to MUX differential channel 1 and measures Young Wind Direction Sensor PLUS the CS100 Barometer
		'(optimized solution to to share the same MUX position). So, first measure WindDirection from the Young... 
	  PulsePort(2,5000)
 	  Delay(0,20,msec)' allows for settling time
    PulseCount(WindSpeed,1,1,1,1,0.098,0)
 	  BrHalf(WindDirection,1,mV2500,14,1,1,2500,True,0,_50Hz,355,0)'consider using fast integration
    ExciteV(Vx3,2500,0)'This MUST be right after any bridge, P107 and PanelTemp preceding the NT1400 measure
	  'If WindDirection>=360 Then WindDirection=0
   
  	'...then measure AirPressure from the CS100. This must never occur less than 1 second from the CS100 gets powered up):
	  VoltSe(AirPressure,1,mV2500,13,1,0,_50Hz,1,-1000.0)

'    '################### WINDMILL SECTION ########################
'    
'    PulsePort(2,5000)
'    Delay(0,20,msec)
'	  VoltSe(Windmill_V,1,mV250,13,1,0,_50Hz,250,0)
'    
'    PulsePort(2,5000)
'    Delay(0,20,msec)
'    VoltDiff(Windmill_A,1,mV250,7,True,0,_50Hz,0.1,0)
 
    
    
    
    '



		'cycles through and measures the 8 thermistors in the thermistor string and the 4 monitored currents
	  For it = 1 To 8 Step 2
	  'first measure the thermistors
 		  PulsePort(2,5000)' COULD THIS REPLACE THE FOLLOWING DELAY???
 		  Delay(0,20,msec)' allows for settling time -> don't remove or measures gets noisy as in 2007
      Therm107 (TemperatureIce(it),1,15,Vx3,20000,_50Hz,1.0,0)
      Therm107 (TemperatureIce(it+1),1,16,Vx3,20000,_50Hz,1.0,0)
      'then measure the current shunts located at the same MUX position
      VoltDiff (Currents((it+1)/2),1,mV7_5,7,True,0,_50Hz,200,0)'200 is for a shunt resistance of 5 mOhm
    Next
    ExciteV(Vx3,2500,0)'This MUST be right after any bridge, P107 and PanelTemp preceding the NT1400 measure
		
		'advances to MUX differential channel 11 and measures tilt values
    PulsePort(2,5000)
	  Delay(0,20,msec)
	  VoltSe(TiltX,1,1,13,1,0,_50Hz,1,0)
	  TiltX = TiltX / 100
	  VoltSe(TiltY,1,1,14,1,0,_50Hz,1,0)
	  TiltY = TiltY / 100

		'advance the MUX to measure the 4 radiation signals from the CNR1 (can too be optimized combining with TS above)
 	  PulsePort(2,5000)
    Delay(0,20,msec)' allows for settling time ... needed??
    VoltDiff (ShortwaveRadiationIn,1,mV25,7,True,0,_50Hz,1,0)
    ShortwaveRadiationIn = ShortwaveRadiationIn * 100  'multiplier to better resemble W/m2
	  PulsePort(2,5000)
    Delay(0,20,msec)' allows for settling time ... needed??
    VoltDiff (LongwaveRadiationIn,1,mV7_5,7,True,0,_50Hz,1,0)
    LongwaveRadiationIn = LongwaveRadiationIn * 100  'multiplier to better resemble W/m2
	  PulsePort(2,5000)
    Delay(0,20,msec)' allows for settling time ... needed??
    VoltDiff (ShortwaveRadiationOut,1,mV25,7,True,0,_50Hz,1,0)
    ShortwaveRadiationOut = ShortwaveRadiationOut * 100  'multiplier to better resemble W/m2
	  PulsePort(2,5000)
    Delay(0,20,msec)' allows for settling time ... needed??
    VoltDiff (LongwaveRadiationOut,1,mV7_5,7,True,0,_50Hz,1,0)
    LongwaveRadiationOut = LongwaveRadiationOut * 100  'multiplier to better resemble W/m2
    BrHalf4W (temp,1,mV25,mV25,3,Vx2,1,2035,True ,True ,0,_50Hz,1.0,0)  ' CHECK for overranges!!
    ExciteV(Vx3,2500,0)'This MUST be right after any bridge, P107 and PanelTemp preceding the NT1400 measure
    PRT (TemperatureRadSensor,1,temp,1.0,0)
		
		'SR50 Sonic Ranging Sensor (SDI-12 Output) measurements.
		'Pre-2014a: SR50A ice is ch. 0 (Height2 array) and CR50A snow is ch. 1 (Height1 array), both blue wires in C7;
		'from 2014a: SR50A ice blue wire remains in C7, SR50A snow is moved from C7 to C3. Both sensors preferably set to ch. 0 (will stll work if any one of them is set to ch. 1 but it will waste a little power)
		'Note that failure is detected as NAN on the second value returned, the quality number, because the first value can be NAN also when the membrane fails, in which case retrying is pointless.
	  While TimeSince12Von < SR50Warmup
      TimeSince12Von = Timer(2,sec,4)
	  Wend
    If FastScanMode OR LastFastScan OR TimeIntoInterval(0,ScanRate,sec) Then
      If SR50_wired_together Then 'SR50_wired_together is True for old stations. To work, this requires that the two sonic rangers are indeed set to different SDI channel numbers
        SDI12Recorder(Height1(),7,SR50Address1,"M1!",1.0,0)
        SDI12Recorder(Height2(),7,SR50Address2,"M1!",1.0,0)
        'look elsewhere for snow
        If Height1(1) = NAN Then SDI12Recorder(Height1(),3,SR50Address1,"M1!",1.0,0) 'see if it was moved to C3 instead
        If Height1(1) = NAN Then
          alternativeSR50Address1 = ABS(SR50Address1 - 1)'only works for SR50Address1 set to either 0 or 1
          SDI12Recorder(Height1(),3,alternativeSR50Address1,"M1!",1.0,0) 'see if it was moved to C3 instead and with a differenc channel number
        EndIf
        'look elsewhere for ice
        If Height2(1) = NAN Then SDI12Recorder(Height2(),3,SR50Address2,"M1!",1.0,0) 'see if it was moved to C3 instead
        If Height2(1) = NAN Then
          alternativeSR50Address2 = ABS(SR50Address2 - 1)'only works for SR50Address1 set to either 0 or 1
          SDI12Recorder(Height2(),3,alternativeSR50Address2,"M1!",1.0,0) 'see if it was moved to C3 instead and with a differenc channel number
        EndIf
        'note that, in the strange case of only one SR50 is attached to the station on C3 and SR50_wired_together is True, that sensor 
        'is read twice and both snow and ice measurements receive these same values. 
      EndIf
      
      If NOT SR50_wired_together Then 'being on same channel means they must be physically wired to different control ports on the logger, or none will work (they will talk on each other)
        'snow
        SDI12Recorder(Height1(),3,SR50Address1,"M1!",1.0,0) 'Looks for the blue wire from the snow SR50 on C3
        If Height1(1) = NAN Then 'in case the SR50 is an old unit still set to channel 1 and it didn't answer, try again with channel 1
          alternativeSR50Address1 = ABS(SR50Address1 - 1)'only works for SR50Address1 set to either 0 or 1
          SDI12Recorder(Height1(),3,alternativeSR50Address1,"M1!",1.0,0)
        EndIf
        If Height1(1) = NAN Then 'in case the wiring was not updated, fall back to old SR50_wired_together = True behaviour (can only work if the two SR50's are indeed set to different channel numbers)
          SDI12Recorder(Height1(),7,SR50Address1,"M1!",1.0,0)
        EndIf
       
        'ice
        SDI12Recorder(Height2(),7,SR50Address2,"M1!",1.0,0) 'Looks for the blue wire from the ice SR50 on C7
        If Height2(1) = NAN Then 'in case the SR50 is an old unit still set to channel 1 and it didn't answer, try again with channel 1
          alternativeSR50Address2 = ABS(SR50Address2 - 1)'only works for SR50Address2 set to either 0 or 1
          SDI12Recorder(Height2(),7,alternativeSR50Address2,"M1!",1.0,0)
        EndIf
        If Height2(1) = NAN Then 'in case the wiring was not updated, fall back to old SR50_wired_together = True behaviour (can only work if the two SR50's are indeed set to different channel numbers)
          SDI12Recorder(Height2(),7,SR50Address2,"M1!",1.0,0)
        EndIf
      EndIf       
    EndIf

		'HygroClip and PT100 measurements (the fan is not switched off here!!)
    PulsePort(2,5000)
    Delay(0,20,msec)		
	  While TimeSince12Von < HygroClipWarmup
      TimeSince12Von = Timer(2,sec,4)
	  Wend
	  VoltSe(Temperature2,1,6,14,0,0,_50Hz,1,0)  ' autorange
	  VoltSe(RelativeHumidity,1,1,13,1,0,_50Hz,1,0)
	  BrHalf4W (temp,1,mV25,mV25,1,Vx2,1,2035,True ,True ,0,_50Hz,1.0,0)'Rotronic Pt100
          ExciteV(Vx3,2500,0)'This MUST be right after any bridge, P107 and PanelTemp preceding the NT1400 measure
    If Asp_fan_on Then Aspirated_Meas = True Else Aspirated_Meas = False' so that we know how our data were collected
    FanPowerDueForSwOff = True'If NOT (FastScanMode) Then FanPowerDueForSwOff = True
	  Temperature2=Temperature2*.1
	  RelativeHumidity=RelativeHumidity*.1
	  PRT (Temperature,1,temp,1.0,0)
		
		' Skipping the part where the unventilated Rotronics assembly used to be
	  PulsePort(2,5000)
    Delay(0,20,msec)		
'		ExciteV(Vx3,2500,0)'This MUST be right after any bridge, P107 and PanelTemp preceding the NT1400 measure

    'Now the NT1400 water column pressure transducer
		PulsePort(2,5000)
    Delay(0,20,msec)		
    ExciteV(Vx3,2500,0)
 		While TimeSinceVx3on < NT1400Warmup
      TimeSinceVx3on = Timer(3,sec,4)
 		Wend
    BrFull (IceHeight,1,mV250,7,Vx3,1,2500,True ,True ,10000,_50Hz,1.0,0)
    Timer(3,sec,3)		

		'resets the MUX (so that even if 12V switched is powered, the MUX itself should only draw standby current)
		PortSet(1,false)
		
  'do now whatever needs the 12V switched supply to be ON and requires warm-up, but doesn't use the MUX 

    'GPS work for Garmin (G) or NAL (N) units, or both!
    PreParseStr(7) = 0
    PreParseStr(9) = 0
    'The Garmin part finds its com2 already open and the prog closes it afterward, so to work
    'around the CR1000 bug causing higher power draw if we open/close com2 here (CPU doesn't go to sleep)
    'If GarminInitOk AND TxModuleGPSpowerOn AND (GPSinUse = "G") Then 'cannot use anymore starting from 2014a
      'GGPSFLAG = true
      'GPGGAsentence = ""
      'SerialFlush(com2)'added yesterday 
      '  If SerialOut(com2,"","$GPGGA",1,250) Then
      '    GPSmessageTimer = Timer(4, sec, 2)
      '    SplitStr(PreParseStr(1),GPGGAsentence,CHR(44),15,5)
      '    PreQual_FP = PreParseStr(7)'we need to do this explicit conversion to float even if the docs claims that it would be done automatically when needed
      '    PreHDOP_FP = PreParseStr(9)'we need to do this explicit conversion to float even if the docs claims that it would be done automatically when needed
      '    If PreQual_FP > 0 AND PreHDOP_FP > 0 AND PreHDOP_FP <= BestHDOPseen Then ''''
      '      SplitStr(ParseStr(1),GPGGAsentence,CHR(44),15,5)
      '      BestHDOPseen = HDOP
      '      For it = 1 To 3
      '        GPSTime(it) = Mid(TimeGPS, 2 * it - 1, 2)'Mid(GPSTimeStr(it), 2*it-1, 2)
      '        GPSTime(it)=GPSTimeStr(it)'shouldn'be necessary in two steps like here, but it doesn't work otherwise
      '      Next
      '      Clock2GPSOffset = (60 * (Minute + 60 * Hour) + Second) - (60 * (GPSMinute + 60 * GPSHour) + GPSSecond) - GPS2UTC
      '      ValidGPStime = true
      '    EndIf
      '    If NOT (BestHDOPseen < 100) Then'so to avoid deleting a previously obtained fix if the current one is worse
      '      For ParseStrIT=1 To 15
      '        ParseStr(ParseStrIT)=""
      '      Next
      '    EndIf
      '  EndIf
      'GGPSFLAG = false
      'TxPowerDueForSwOff = True
    'EndIf 

    'The NAL part (it opens and closes its ComRS232 port itself)
    If TxInitializeOk AND TxModuleGPSpowerOn AND (GPSinUse = "N") Then
      NGPSFLAG = true
      GPGGAsentence = ""
      SerialOpen(ComRS232,19200,0,0,150)
      SerialOut(ComRS232,"AT"+CHR(13)+CHR(10),"",1,10)'this is to let the CR1000 ComRS232 port wake up from the automatic power-down
      SerialOut(ComRS232,"AT+PA=1"+CHR(13)+CHR(10),"",1,10)
        If SerialOut(ComRS232,"","$GPGGA",1,150) Then 
          GPSmessageTimer = Timer(4, sec, 2)
          SerialIn(GPGGAsentence,ComRS232,150,"*",150)'was 13
          SplitStr(PreParseStr(1),GPGGAsentence,CHR(44),15,5)
          PreQual_FP = PreParseStr(7)'we need to do this explicit conversion to float even if the docs claims that it would be done automatically when needed
          PreHDOP_FP = PreParseStr(9)'we need to do this explicit conversion to float even if the docs claims that it would be done automatically when needed
          If PreQual_FP > 0 AND PreHDOP_FP > 0 AND PreHDOP_FP <= BestHDOPseen Then ''''
            SplitStr(ParseStr(1),GPGGAsentence,CHR(44),15,5)
            BestHDOPseen = HDOP
            For it = 1 To 3
              GPSTimeStr(it) = Mid(TimeGPS, 2 * it - 1, 2)
              GPSTime(it)=GPSTimeStr(it)'shouldn'be necessary in two steps like here, but it doesn't work otherwise
            Next
            Clock2GPSOffset = (60 * (Minute + 60 * Hour) + Second) - (60 * (GPSMinute + 60 * GPSHour) + GPSSecond) - GPS2UTC
            ValidGPStime = true
            'now tag the values in TimeGPS, Latitude and Longitude so that the binary encoder can recognize them.
            TimeGPS = "GT" + TimeGPS 'GT = GPS time
            If UpperCase(HemisphereNS) = "N" Then Latitude = "NH" + Latitude Else Latitude = "SH" + Latitude
            If UpperCase(HemisphereEW) = "E" Then Longitude = "EH" + Longitude Else Longitude = "WH" + Longitude       
          EndIf
        Else
          TxInitializeOk = False
        EndIf
      If NOT (FastScanMode OR LastFastScan) Then
        SerialOut(ComRS232,"AT+PP=0"+CHR(13)+CHR(10),"",1,10)
      EndIf
      SerialClose(ComRS232)
      NGPSFLAG = false
      TxPowerDueForSwOff = True
    ElseIf (FastScanMode OR LastFastScan)'TODO:review this block (MCIT 07/2010)
      Call TxModuleInit
      If TxInitializeOk Then
        If TxTypeNAL9601DGSLP OR TxTypeNAL9602LP Then 'the old and new Iridium things from NAL have different syntax...
          SerialOut(ComRS232,"AT*S0"+CHR(13)+CHR(10),"",1,10)'shut down the Iridium radio
        EndIf
        If TxTypeNAL960x Then 'the old and new Iridium things from NAL have different syntax...
          SerialOut(ComRS232,"AT*S=0"+CHR(13)+CHR(10),"",1,10)'shut down the Iridium radio
        EndIf
        SerialOut(ComRS232,"AT+PP=1"+CHR(13)+CHR(10),"",1,10)'should be sent as soon as possible after powerup
        SerialOut(ComRS232,"AT+PNAV=1"+CHR(13)+CHR(10),"",1,10)'should be sent as soon as possible after powerup
        SerialClose(ComRS232)
      EndIf
      If NOT (BestHDOPseen < 100) Then'so to avoid deleting a previously obtained fix if the current one is worse
        For ParseStrIT=1 To 15
          ParseStr(ParseStrIT)=""
        Next
      EndIf
    EndIf
		'Final Battery Voltage measurement and Low_Batt check (do this before turning SW12V off)
		Battery(VoltageBatteries)
		If VoltageBatteries < LoBattThre Then Low_Batt = True
		If VoltageBatteries >= LoBattThre + LoBattResHyst Then Low_Batt = False

    Timer(2,sec,3)
	  SW12(False)'Disables switched 12V supply
 		SW12Von=False
  EndIf
 '********************************* DONE WITH THE MEASUREMENTS *************************************
 '**************************************************************************************************

	If TimeIntoInterval(0,ScanRate,sec) OR (ForceTX AND TxModuleGPSPowerOn) Then
    If TimeIntoInterval(0,ScanRate,sec) Then'so that we don't call the Mem and Diag tables if it is just a forced tx
      CallTable(TableDiagnostics)
  '      CallTable(InstantaneousTable)'called not only when its actual values are needed because we can most easily get the current timestamp
  		CallTable(TableMem)
  		CallTable(SlimTableMem)
  	EndIf
    MinutesInYear = DayOfYear * 1440 + Hour * 60 + Minute

    If FanPowerDueForSwOff AND NOT FastScanMode
      PortSet(8,false)
      Asp_fan_on = False
      FanPowerDueForSwOff = False
    EndIf

 		If IsSummer Then
      If TimeIntoInterval(0,ScanRate,sec) Then'so that we don't call the Mem and Diag tables and reset GPS stuff if it is just a forced tx
  		  CallTable(TableSummerTx)
 		  	BestHDOPseen = 100
  		EndIf
 		  If TableSummerTx.Output(1,1) OR ForceTX Then
        dbg_trace_sig=dbg_trace_sig+"[S0"'''''''''''''''''''''''''''''''''''''
 		    TxBufferString=""
 		    TableInstantaneousString=""
 		    TxStringUnstripped=""
 		    TxString=""
 		    GetRecord(TxBufferString,TableSummerTx,1)
 		    If AppendInstantaneous AND TimeIntoInterval(0, HoursInstantaneous, hr) Then
     		  CallTable(InstantaneousTable)
 		      GetRecord(TableInstantaneousString,InstantaneousTable,1)
 		      TxBufferString=Left(TxBufferString, Len(TxBufferString)-2)+","+Mid(TableInstantaneousString,23,Len(TableInstantaneousString)-2)
 		    EndIf
        If TimeIntoInterval(0,ScanRate,sec) Then
 		      If SendRecordBacklog < SizeTableBuffer Then SendRecordBacklog = SendRecordBacklog + 1' otherwise it stays at the maximum depth set in the header
          CallTable(TxBufferTable)
        ElseIf ForceTX AND SendRecordBacklog = 0 Then 'to add an entry in the queue for forced tx only if the queue is empty
          CallTable(TxBufferTable)
          SendRecordBacklog=1
          ResetTxBufferTableDue = True          
        EndIf  		    
        If TimeIntoInterval(0,DiagnosticsRate,hr) AND SendRecordBacklog < SizeTableBuffer Then' if the Tx queue is already full, don't bother with the diagnostics
   		    TxBufferString=""
          GetRecord(TxBufferString,TableDiagnostics,1)
          CallTable(TxBufferTable)
          SendRecordBacklog = SendRecordBacklog + 1
        EndIf
 		     
 		    For SendRecordIT = SendRecordBacklog To 1 Step -1
          TxString=""
		      MPFLAG=true'remove!!
 		      Delay(0,2,sec)'remove!!  		      'Call AppendInstantMeas  		      'Call StripTxStringDown
 		      GetRecord(TxStringUnstripped,TxBufferTable,SendRecordIT)
 		      StripStringStart = InStr(1,TxStringUnstripped,CHR(34)+CHR(34),4)
 		      For StringStripperIT=StripStringStart To Len(TxStringUnstripped)-5'5 is a magic number. Don't take the magic out!
 		        StringChar=Mid(TxStringUnstripped, StringStripperIT, 1)
 		        If StringChar<>CHR(34) Then TxString=TxString+StringChar
 		      Next StringStripperIT
 		      TxString=TxString+",!M"    '''''''''''''''''''
          dbg_trace_sig=dbg_trace_sig+"1"'''''''''''''''''''''''''''''''''''''
' 		      If TransmitBinary = True Then Call BinaryEncode
 		      Call IridiumTx
          dbg_trace_sig=dbg_trace_sig+"2"'''''''''''''''''''''''''''''''''''''
 		      MPFLAG=false'remove!!
 		      If NOT TxSendSuccess Then ExitFor'if the transmission of the current message fail then don't even try to send the queue
        dbg_trace_sig=dbg_trace_sig+"3"'''''''''''''''''''''''''''''''''''''
 		    Next
        dbg_trace_sig=dbg_trace_sig+"4]"'''''''''''''''''''''''''''''''''''''
 		    If SendRecordIT = 0 Then ResetTable(TxBufferTable)
 		    If ResetTxBufferTableDue Then
 		      ResetTable(TxBufferTable)'to get rid of the message that was added to the queue just for the purpose of a forced tx and remained there after the tx failed
          ResetTxBufferTableDue = False
 		      SendRecordIT = 0
 		    EndIf
 		    SendRecordBacklog = SendRecordIT
        TxPowerDueForSwOff = True
 		    ForceTX = False
 		  EndIf
 		EndIf
 		If NOT IsSummer Then
      If TimeIntoInterval(0,ScanRate,sec) Then'so that we don't call the Mem and Diag tables and reset GPS stuff if it is just a forced tx
  		  CallTable(TableWinterTx)
 		  	BestHDOPseen = 100
  		EndIf
 		  If TableWinterTx.Output(1,1) OR ForceTX Then
        dbg_trace_sig=dbg_trace_sig+"[S0"'''''''''''''''''''''''''''''''''''''
 		    TxBufferString=""
 		    TableInstantaneousString=""
 		    TxStringUnstripped=""
 		    TxString=""
 		    GetRecord(TxBufferString,TableWinterTx,1)
 		    If AppendInstantaneous AND TimeIntoInterval(0, HoursInstantaneous, hr) Then
     		  CallTable(InstantaneousTable)
 		      GetRecord(TableInstantaneousString,InstantaneousTable,1)
 		      TxBufferString=Left(TxBufferString, Len(TxBufferString)-2)+","+Mid(TableInstantaneousString,23,Len(TableInstantaneousString)-2)
 		    EndIf
        If TimeIntoInterval(0,ScanRate,sec) Then
 		      If SendRecordBacklog < SizeTableBuffer Then SendRecordBacklog = SendRecordBacklog + 1' otherwise it stays at the maximum depth set in the header
          CallTable(TxBufferTable)
        ElseIf ForceTX AND SendRecordBacklog = 0 Then 'to add an entry in the queue for forced tx only if the queue is empty
          CallTable(TxBufferTable)
          SendRecordBacklog=1
          ResetTxBufferTableDue = True          
        EndIf  		    
        If TimeIntoInterval(0,DiagnosticsRate,hr) AND SendRecordBacklog < SizeTableBuffer Then' if the Tx queue is already full, don't bother with the diagnostics
   		    TxBufferString=""
          GetRecord(TxBufferString,TableDiagnostics,1)
          CallTable(TxBufferTable)
          SendRecordBacklog = SendRecordBacklog + 1
        EndIf
 		     
 		    For SendRecordIT = SendRecordBacklog To 1 Step -1
          TxString=""
		      MPFLAG=true'remove!!
 		      Delay(0,2,sec)'remove!!  		      'Call AppendInstantMeas  		      'Call StripTxStringDown
 		      GetRecord(TxStringUnstripped,TxBufferTable,SendRecordIT)
 		      StripStringStart = InStr(1,TxStringUnstripped,CHR(34)+CHR(34),4)
 		      For StringStripperIT=StripStringStart To Len(TxStringUnstripped)-5'5 is a magic number. Don't take the magic out!
 		        StringChar=Mid(TxStringUnstripped, StringStripperIT, 1)
 		        If StringChar<>CHR(34) Then TxString=TxString+StringChar
 		      Next StringStripperIT
 		      TxString=TxString+",!M"    '''''''''''''''''''
          dbg_trace_sig=dbg_trace_sig+"1"'''''''''''''''''''''''''''''''''''''
' 		      If TransmitBinary = True Then Call BinaryEncode
 		      Call IridiumTx
          dbg_trace_sig=dbg_trace_sig+"2"'''''''''''''''''''''''''''''''''''''
 		      MPFLAG=false'remove!!
 		      If NOT TxSendSuccess Then ExitFor'if the transmission of the current message fail then don't even try to send the queue
        dbg_trace_sig=dbg_trace_sig+"3"'''''''''''''''''''''''''''''''''''''
 		    Next
        dbg_trace_sig=dbg_trace_sig+"4]"'''''''''''''''''''''''''''''''''''''
 		    If SendRecordIT = 0 Then ResetTable(TxBufferTable)
 		    If ResetTxBufferTableDue Then
 		      ResetTable(TxBufferTable)'to get rid of the message that was added to the queue just for the purpose of a forced tx and remained there after the tx failed
          ResetTxBufferTableDue = False
 		      SendRecordIT = 0
 		    EndIf
 		    SendRecordBacklog = SendRecordIT
        TxPowerDueForSwOff = True
 		    ForceTX = False
 		  EndIf
 		EndIf 		
    If TimeIntoInterval(0,ScanRate,sec) Then'so that we don't touch VoltageBatteriesIni if it is just a forced tx
      VoltageBatteriesIni = -999  ' 'VoltageBatteries' instead doesn't need such a NODATA value, so it is left as it is for convenience
    EndIf
  EndIf

  If TxPowerDueForSwOff AND NOT (FastScanMode OR LastFastScan) Then
    SerialOut(ComRS232,"AT*F"+CHR(13)+CHR(10),"OK",1,100)' to allow 5 secs for the Iridium Module to start listening to the serial bus
    Delay(0,1,sec)
    PortSet(6,false)
    TxModuleGPSPowerOn = False
    TxInitializeOk = False'turn this off??
    TxPowerDueForSwOff = False
  EndIf
  If LastFastScan Then LastFastScan = False

  If FanPowerDueForSwOff AND NOT FastScanMode
    PortSet(8,false)
    Asp_fan_on = False
    FanPowerDueForSwOff = False
  EndIf

  If AllowResetToGPStime OR KeepSyncToGPStime Then'WARNING: THIS ARE UNTESTED!!! Leave AllowReseTtoGPStime = KeepSyncToGPStime = False in the field!!!
    For it = 1 To 4
      NewClock(it) = RTime(it)
    Next
    GPSmessageTimer = Timer(4, sec, 4)
    NewClock(5) = RTime(5) + FIX((Clock2GPSOffset + GPSmessageTimer) / 3600)
    NewClock(6) = RTime(6) + FIX(((Clock2GPSOffset + GPSmessageTimer) MOD 3600) / 60)
    NewClock(7) = RTime(7) + FIX((Clock2GPSOffset + GPSmessageTimer) MOD 60)   
    If AllowResetToGPStime OR Clock2GPSOffset <= AllowableTimeDrift Then ClockSet(NewClock())
  EndIf
  ValidGPStime = False
  Timer(4, sec, 3)
 
  SerialClose(ComRS232)
  'VoltageBatteriesIni = -999  ' 'VoltageBatteries' instead doesn't need such a NODATA value, so it is left as it is for convenience
  PulsePort(5,10000)'blink the led

NextScan    
EndProg
